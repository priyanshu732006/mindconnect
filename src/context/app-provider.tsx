
'use client';

import { analyzeWellbeing, sendSmsAction } from '@/app/actions';
import type { Message, WellbeingData, TrustedContact, FacialAnalysisData, VoiceAnalysisData, NavItem } from '@/lib/types';
import React, { useMemo } from 'react';
import { useToast } from '@/hooks/use-toast';
import { getWellbeingCategory } from '@/lib/utils';
import { useAuth } from './auth-provider';
import { studentNavItems } from '@/lib/student-nav';
import { adminNavItems } from '@/lib/admin-nav';
import { counsellorNavItems } from '@/lib/counsellor-nav';
import { peerBuddyNavItems } from '@/lib/peer-buddy-nav';

type AppContextType = {
  messages: Message[];
  setMessages: React.Dispatch<React.SetStateAction<Message[]>>;
  addMessage: (role: 'user' | 'assistant', content: string) => void;
  wellbeingData: WellbeingData | null;
  isAnalyzing: boolean;
  trustedContacts: TrustedContact[];
  addContact: (contact: Omit<TrustedContact, 'id' | 'avatar'>) => void;
  updateContact: (contact: TrustedContact) => void;
  deleteContact: (contactId: string) => void;
  facialAnalysis: FacialAnalysisData | null;
  setFacialAnalysis: React.Dispatch<React.SetStateAction<FacialAnalysisData | null>>;
  voiceAnalysis: VoiceAnalysisData | null;
  setVoiceAnalysis: React.Dispatch<React.SetStateAction<VoiceAnalysisData | null>>;
  navItems: NavItem[];
};

const AppContext = React.createContext<AppContextType | undefined>(undefined);

export function AppProvider({ children }: { children: React.ReactNode }) {
  const [messages, setMessages] = React.useState<Message[]>([]);
  const [wellbeingData, setWellbeingData] = React.useState<WellbeingData | null>(null);
  const [isAnalyzing, setIsAnalyzing] = React.useState(false);
  const [trustedContacts, setTrustedContacts] = React.useState<TrustedContact[]>([]);
  const [facialAnalysis, setFacialAnalysis] = React.useState<FacialAnalysisData | null>(null);
  const [voiceAnalysis, setVoiceAnalysis] = React.useState<VoiceAnalysisData | null>(null);

  const { toast } = useToast();
  const { user, role } = useAuth();

  const navItems = useMemo(() => {
    switch (role) {
      case 'admin':
        return adminNavItems;
      case 'counsellor':
        return counsellorNavItems;
      case 'peer-buddy':
        return peerBuddyNavItems;
      default:
        return studentNavItems;
    }
  }, [role]);

  const addMessage = (role: 'user' | 'assistant', content: string) => {
    setMessages(prev => [...prev, { id: Date.now().toString(), role, content }]);
  };

  const analyzeCurrentState = React.useCallback(async () => {
    if (messages.length === 0 && !facialAnalysis && !voiceAnalysis) {
      setWellbeingData({ wellbeingScore: 0, summary: "Start a conversation or use the analysis tools to get your well-being score.", selfHarmRisk: false });
      return;
    }

    setIsAnalyzing(true);
    try {
      const data = await analyzeWellbeing(messages, facialAnalysis, voiceAnalysis);
      if (data) {
        setWellbeingData(data);
      }
    } catch (error) {
      console.error('Failed to analyze conversation:', error);
    } finally {
      setIsAnalyzing(false);
    }
  }, [messages, facialAnalysis, voiceAnalysis]);

   const addContact = (contact: Omit<TrustedContact, 'id' | 'avatar'>) => {
    const newId = (trustedContacts.length + 1).toString() + Date.now().toString();
    setTrustedContacts(prev => [
      ...prev,
      { 
        ...contact, 
        id: newId,
        avatar: `https://picsum.photos/seed/${newId}/100/100`
      },
    ]);
  };

  const updateContact = (updatedContact: TrustedContact) => {
    setTrustedContacts(prev =>
      prev.map(c => (c.id === updatedContact.id ? updatedContact : c))
    );
  };

  const deleteContact = (contactId: string) => {
    setTrustedContacts(prev => prev.filter(c => c.id !== contactId));
  };
  
  React.useEffect(() => {
    analyzeCurrentState();
  }, [messages, facialAnalysis, voiceAnalysis, analyzeCurrentState]);
  
  const triggerCrisisAlerts = React.useCallback(async (currentContacts: TrustedContact[], isSelfHarmRisk: boolean) => {
    if (!user || !user.displayName) {
        // Don't send alerts if there's no user or user name.
        return;
    }
    const studentName = user.displayName;
    
    let messageBody: string;

    if(isSelfHarmRisk) {
        messageBody = `Hi, this is an Autogenerated message \n  "${studentName}" is in severe distress and there is a high probability of self harm , please immediately check upon him before its too late.`;
    } else {
        messageBody = `Crisis Alert: ${studentName} may be in distress. Please check in with them. This is an automated message from the Student Wellness Hub.`;
    }


    if(currentContacts.length === 0) {
        toast({
            variant: 'destructive',
            title: 'No Trusted Contacts',
            description: 'Please add a trusted contact to send crisis alerts.',
            duration: 10000,
        });
        return;
    }

    const contactPromises = currentContacts.map(contact => 
        sendSmsAction(contact.phone, messageBody)
    );

    const results = await Promise.all(contactPromises);
    const successfulContacts = currentContacts.filter((_, index) => results[index].success);
    const failedContacts = currentContacts.map((contact, index) => ({ ...contact, result: results[index] })).filter(c => !c.result.success);


    if (successfulContacts.length > 0) {
        const contactNames = successfulContacts.map(c => c.name).join(', ');
        toast({
            variant: 'destructive',
            title: 'Crisis Alert Triggered',
            description: `An SMS alert has been sent to your trusted contacts: ${contactNames}.`,
            duration: 10000,
        });
    }

    if (failedContacts.length > 0) {
        const failedContactNames = failedContacts.map(c => c.name).join(', ');
        const firstError = failedContacts[0].result.error;
        toast({
            variant: 'destructive',
            title: 'SMS Failed for Some Contacts',
            description: `Could not send SMS to ${failedContactNames}. Reason: ${firstError}`,
            duration: 10000,
        });
    }
  }, [user, toast]);

  React.useEffect(() => {
    if (wellbeingData && wellbeingData.wellbeingScore > 0) {
      const { name } = getWellbeingCategory(wellbeingData.wellbeingScore);
      if (name === 'Crisis') {
        triggerCrisisAlerts(trustedContacts, wellbeingData.selfHarmRisk);
      }
    }
  }, [wellbeingData, triggerCrisisAlerts, trustedContacts]);


  const value = {
    messages,
    setMessages,
    addMessage,
    wellbeingData,
    isAnalyzing,
    trustedContacts,
    addContact,
    updateContact,
    deleteContact,
    facialAnalysis,
    setFacialAnalysis,
    voiceAnalysis,
    setVoiceAnalysis,
    navItems,
  };

  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;
}

export function useApp() {
  const context = React.useContext(AppContext);
  if (context === undefined) {
    throw new Error('useApp must be used within an AppProvider');
  }
  return context;
}
